#include <stdio.h>
#include <ctype.h>
#include <string.h>

//global variables
//variables
int char_class;
char lexeme[100];
char next_char;
int lex_len;
int token;
int next_token;
FILE *in_fp, *fopen();

//function declarations
void add_char();
void get_char();
void get_non_blank();
int lex();
void while_expr();
int while_parse();
void bool_expr();
void code();

//character classes
#define LETTER 0
#define DIGIT 1
#define UNKNOWN 99

//token codes
#define INT_LIT 10
#define IDENT 11
#define ASSIGN_OP 20
#define ADD_OP 21
#define SUB_OP 22
#define MULT_OP 23
#define DIV_OP 24
#define LEFT_PAREN 25
#define RIGHT_PAREN 26
#define BOOL_OP 27
#define OPEN_BRACE 28
#define CLOSE_BRACE 29
#define SEMI_COLON 30

int main()
{
	/* Open the input data file and process its contents */
	if ((in_fp = fopen("while.in", "r")) == NULL)
		printf("ERROR - cannot open front.in \n");

	else {
		get_char();
		while_expr();
		/*
		do {
			lex();
		} while (next_token != EOF);
		*/
	}

	return 0;
}

/* lookup - a function to lookup operators and parentheses
and return the token */
int lookup(char ch)
{
	switch (ch) {
		case '(':
			add_char();
			next_token = LEFT_PAREN;
			break;
		case ')':
			add_char();
			next_token = RIGHT_PAREN;
			break;
		case '+':
			add_char();
			next_token = ADD_OP;
			break;
		case '-':
			add_char();
			next_token = SUB_OP;
			break;
		case '*':
			add_char();
			next_token = MULT_OP;
			break;
		case '/':
			add_char();
			next_token = DIV_OP;
			break;
		case '<':
		case '>':
		case '=':
		case '!':
		case '|':
		case '&':
			add_char();
			next_token = BOOL_OP;
			break;
		case '{':
			add_char();
			next_token = OPEN_BRACE;
			break;
		case '}':
			add_char();
			next_token = CLOSE_BRACE;
			break;
		case ';':
			add_char();
			next_token = SEMI_COLON;
			break;
		default:
			add_char();
			next_token = EOF;
			break;
	}

	return next_token;
}

/* add_char - a function to add next_char to lexeme */
void add_char()
{
	if (lex_len <= 98) {
		lexeme[lex_len++] = next_char;
		lexeme[lex_len] = 0;
	} else {
		printf("Error - lexeme is too long \n");
	}
}

/* get_char - a function to get the next character of input and determine its
 * character class
 */
void get_char()
{
	if ((next_char = getc(in_fp)) != EOF) {
		if (isalpha(next_char))
			char_class = LETTER;
		else if (isdigit(next_char))
			char_class = DIGIT;
		else char_class = UNKNOWN;
	} else {
		char_class = EOF;
	}
}

/* get_non_blank - a function to call get_char until it returns a non-whitespace
 * character
 */
void get_non_blank()
{
	while (isspace(next_char))
		get_char();
}

//lex - a simple lexical analyzer for arithmetic expressions
int lex()
{
	lex_len = 0;
	get_non_blank();
	switch (char_class) {
		case LETTER: //parse identifiers
			add_char();
			get_char();
			while (char_class == LETTER || char_class == DIGIT) {
				add_char();
				get_char();
			}
			next_token = IDENT;
			break;
		case DIGIT: //parse integer literals
			add_char();
			get_char();
			while (char_class == DIGIT) {
				add_char();
				get_char();
			}
			next_token = INT_LIT;
			break;
		case UNKNOWN: // parentheses and operators
			lookup(next_char);
			get_char();
			break;
		case EOF: //End Of File
			next_token = EOF;
			lexeme[0] = 'E';
			lexeme[1] = 'O';
			lexeme[2] = 'F';
			lexeme[3] = 0;
			break;
	} //end of switch
	printf("Next token is: %d, Next lexeme is %s\n", next_token, lexeme);

	return next_token;
} //end of function lex

/* expr
Parses strings in the language generated by the rule:
<while> -> while \(<bool>\) <code>
*/
void while_expr()
{
	printf("Enter <while>\n");

	/* Parse the while */
	if(!while_parse())
		goto END_WHILE;

	/* Parse the bool */
	bool_expr();

	/* Parse the code */
	code();

	END_WHILE:
	printf("Exit <while>\n");
}

int while_parse()
{
	lex();

	char while_check[6]; //check for "while"
	for (int i = 0; i < 5; i++)
		while_check[i] = lexeme[i];
	while_check[5] = '\0';

	if (strcmp(while_check, "while") != 0) { //if it's not "while"
		printf("[error]: Invalid syntax, expected \"while\"\n");
		return 0; //fail
	}

	return 1; //success
}

void bool_expr()
{
	printf("Enter <bool>\n");

	//opening parenthesis
	lex();

	if (lexeme[0] != '(') {
		printf("[error]: Invalid syntax, expected \"(\"\n");
		goto END_BOOL;
	}

	//boolean stuff
	lex();
	while (next_token == BOOL_OP || next_token == IDENT)
		lex();

	//closing parenthesis
	if (lexeme[0] != ')') {
		printf("[error]: Invalid syntax, expected \")\"\n");
		goto END_BOOL;
	}

	END_BOOL:
	printf("Exit <bool>\n");
}

void code()
{
	printf("Enter <code>\n");

	lex();
	if (lexeme[0] == '{') { //multiple code statements
		while (next_token != CLOSE_BRACE && next_token != EOF)
			lex();
		if (next_token == CLOSE_BRACE) {
			//cool, we reached the end. Do nothing
		} else { //it reached EOF
			printf("[error]: Invalid syntax, expected \"}\"\n");
		}
	} else {
		lex(); //just one statement, lex it
	}

	printf("Exit <code>\n");
}
